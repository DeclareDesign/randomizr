<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Design and analysis of experiments with randomizr • randomizr</title>
<!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous">
<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous">
<!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet">
<script src="../jquery.sticky-kit.min.js"></script><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]-->
</head>
<body>
    <div class="container template-article">
      <header><div class="navbar navbar-default navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
<li>
  <a href="../articles/randomizr_vignette.html">Getting Started in R</a>
</li>
<li>
  <a href="../articles/srandomizr_vignette.html">Getting Started in Stata</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="http://discuss.declaredesign.org">Ask for Help</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Packages
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
<li>
      <a href="http://declaredesign.org">DeclareDesign</a>
    </li>
    <li>
      <a href="https://declaredesign.org/r/randomizr/">randomizr</a>
    </li>
    <li>
      <a href="https://declaredesign.org/r/fabricatr/">fabricatr</a>
    </li>
    <li>
      <a href="https://declaredesign.org/r/estimatr/">estimatr</a>
    </li>
  </ul>
</li>
<li>
  <a href="http://declaredesign.org">DeclareDesign home</a>
</li>
      </ul>
<ul class="nav navbar-nav navbar-right">
<li>
  <a></a>
</li>
      </ul>
</div>
<!--/.nav-collapse -->
  </div>
<!--/.container -->
</div>
<!--/.navbar -->

      
      </header><div class="row">
  <div class="col-md-9 contents">
    <div class="page-header toc-ignore">
      <h1>Design and analysis of experiments with randomizr</h1>
                        <h4 class="author">Alexander Coppock</h4>
            
      
      <small class="dont-index">Source: <a href="https://github.com/DeclareDesign/randomizr/blob/master/vignettes/randomizr_vignette.Rmd"><code>vignettes/randomizr_vignette.Rmd</code></a></small>
      <div class="hidden name"><code>randomizr_vignette.Rmd</code></div>

    </div>

    
    
<p><strong>randomizr</strong> is a small package for r that simplifies the design and analysis of randomized experiments. In particular, it makes the random assignment <strong>procedure</strong> transparent, flexible, and most importantly reproduceable. By the time that many experiments are written up and made public, the process by which some units recieved treatments is lost or imprecisely described. The <strong>randomizr</strong> package makes it easy for even the most forgetful of researchers to generate error-free, reproduceable random assignments.</p>
<p>A hazy understanding of the random assignment procedure leads to two main problems at the analysis stage. First, units may have different probabilities of assignment to treatment. Analyzing the data as though they have the same probabilities of assignment leads to biased estimates of the treatment effect. Second, units are sometimes assigned to treatment as a <strong>cluster</strong>. For example, all the students in a single classroom may be assigned to the same intervention together. If the analysis ignores the clustering in the assignments, estimates of average causal effects and the uncertainty attending to them may be incorrect.</p>
<div id="a-hypothetical-experiment" class="section level1">
<h1 class="hasAnchor">
<a href="#a-hypothetical-experiment" class="anchor"></a>A hypothetical experiment</h1>
<p>Throughout this vignette, we’ll pretend we’re conducting an experiment among the 592 individuals in the built-in <code>HairEyeColor</code> dataset. As we’ll see, there are many ways to randomly assign subjects to treatments. We’ll step through five common designs, each associated with one of the five <code>randomizr</code> functions: <code><a href="../reference/simple_ra.html">simple_ra()</a></code>, <code><a href="../reference/complete_ra.html">complete_ra()</a></code>, <code><a href="../reference/block_ra.html">block_ra()</a></code>, <code><a href="../reference/cluster_ra.html">cluster_ra()</a></code>, and <code><a href="../reference/block_and_cluster_ra.html">block_and_cluster_ra()</a></code>.</p>
<p>We first need to transform the dataset, which has each row describe a <strong>type</strong> of subject, to a new dataset in which each row describes an individual subject.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Load built-in dataset</span>
<span class="kw">data</span>(HairEyeColor)
HairEyeColor &lt;-<span class="st"> </span><span class="kw">data.frame</span>(HairEyeColor)

<span class="co"># Transform so each row is a subject</span>
<span class="co"># Columns describe subject's hair color, eye color, and gender</span>
hec &lt;-<span class="st"> </span>HairEyeColor[<span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(HairEyeColor),
                        <span class="dt">times =</span> HairEyeColor<span class="op">$</span>Freq), <span class="dv">1</span><span class="op">:</span><span class="dv">3</span>]

N &lt;-<span class="st"> </span><span class="kw">nrow</span>(hec)

<span class="co"># Fix the rownames</span>
<span class="kw">rownames</span>(hec) &lt;-<span class="st"> </span><span class="ot">NULL</span></code></pre></div>
<p>Typically, researchers know some basic information about their subjects before deploying treatment. For example, they usually know how many subjects there are in the experimental sample (N), and they usually know some basic demographic information about each subject.</p>
<p>Our new dataset has 592 subjects. We have three pretreatment covariates, <code>Hair</code>, <code>Eye</code>, and <code>Sex</code>, which describe the hair color, eye color, and gender of each subject.</p>
<p>We now need to create simulated <em>potential outcomes</em>. We’ll call the untreated outcome <code>Y0</code> and we’ll call the treated outcome <code>Y1</code>. Imagine that in the absence of any intervention, the outcome (<code>Y0</code>) is correlated with out pretreatment covariates. Imagine further that the effectiveness of the program varies according to these covariates, i.e., the difference between <code>Y1</code> and <code>Y0</code> is correlated with the pretreatment covariates.</p>
<p>If we were really running an experiment, we would only observe either <code>Y0</code> or <code>Y1</code> for each subject, but since we are simulating, we generate both. Our inferential target is the average treatment effect (ATE), which is defined as the average difference between <code>Y0</code> and <code>Y1</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Set a seed for reproducability</span>
<span class="kw">set.seed</span>(<span class="dv">343</span>)

<span class="co"># Create untreated and treated outcomes for all subjects</span>
hec &lt;-<span class="st"> </span><span class="kw">within</span>(hec,{
  Y0 &lt;-<span class="st"> </span><span class="kw">rnorm</span>(<span class="dt">n =</span> N,<span class="dt">mean =</span> (<span class="dv">2</span><span class="op">*</span><span class="kw">as.numeric</span>(Hair) <span class="op">+</span><span class="st"> </span><span class="op">-</span><span class="dv">4</span><span class="op">*</span><span class="kw">as.numeric</span>(Eye) <span class="op">+</span><span class="st"> </span><span class="op">-</span><span class="dv">6</span><span class="op">*</span><span class="kw">as.numeric</span>(Sex)), <span class="dt">sd =</span> <span class="dv">5</span>)
  Y1 &lt;-<span class="st"> </span>Y0 <span class="op">+</span><span class="st"> </span><span class="dv">6</span><span class="op">*</span><span class="kw">as.numeric</span>(Hair) <span class="op">+</span><span class="st"> </span><span class="dv">4</span><span class="op">*</span><span class="kw">as.numeric</span>(Eye) <span class="op">+</span><span class="st"> </span><span class="dv">2</span><span class="op">*</span><span class="kw">as.numeric</span>(Sex)
})

<span class="co"># Calculate true ATE</span>
<span class="kw">with</span>(hec, <span class="kw">mean</span>(Y1 <span class="op">-</span><span class="st"> </span>Y0))
<span class="co">#&gt; [1] 25</span></code></pre></div>
<p>We are now ready to allocate treatment assignments to subjects. Let’s start by contrasting simple and complete random assignment.</p>
<div id="simple-random-assignment" class="section level2">
<h2 class="hasAnchor">
<a href="#simple-random-assignment" class="anchor"></a>Simple random assignment</h2>
<p>Simple random assignment assigns all subjects to treatment with an equal probability by flipping a (weighted) coin for each subject. The main trouble with simple random assignment is that the number of subjects assigned to treatment is itself a random number - depending on the random assignment, a different number of subjects might be assigned to each group.</p>
<p>The <code><a href="../reference/simple_ra.html">simple_ra()</a></code> function has one required argument <code>N</code>, the total number of subjects. If no other arguments are specified, <code><a href="../reference/simple_ra.html">simple_ra()</a></code> assumes a two-group design and a 0.50 probability of assignment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(randomizr)
Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simple_ra.html">simple_ra</a></span>(<span class="dt">N =</span> N)
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">301</td>
<td align="right">291</td>
</tr></tbody>
</table>
<p>To change the probability of assignment, specify the <code>prob</code> argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simple_ra.html">simple_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">prob =</span> <span class="fl">0.30</span>)
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">402</td>
<td align="right">190</td>
</tr></tbody>
</table>
<p>If you specify <code>num_arms</code> without changing <code>prob_each</code>, <code><a href="../reference/simple_ra.html">simple_ra()</a></code> will assume equal probabilities across all arms.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simple_ra.html">simple_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">num_arms =</span> <span class="dv">3</span>)
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">191</td>
<td align="right">215</td>
<td align="right">186</td>
</tr></tbody>
</table>
<p>You can also just specify the probabilities of your multiple arms. The probabilities must sum to 1.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simple_ra.html">simple_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">prob_each =</span> <span class="kw">c</span>(.<span class="dv">2</span>, .<span class="dv">2</span>, .<span class="dv">6</span>))
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">118</td>
<td align="right">119</td>
<td align="right">355</td>
</tr></tbody>
</table>
<p>You can also name your treatment arms.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simple_ra.html">simple_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">prob_each =</span> <span class="kw">c</span>(.<span class="dv">2</span>, .<span class="dv">2</span>, .<span class="dv">6</span>),
               <span class="dt">conditions=</span><span class="kw">c</span>(<span class="st">"control"</span>, <span class="st">"placebo"</span>, <span class="st">"treatment"</span>))
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">control</th>
<th align="right">placebo</th>
<th align="right">treatment</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">132</td>
<td align="right">108</td>
<td align="right">352</td>
</tr></tbody>
</table>
</div>
<div id="complete-random-assignment" class="section level2">
<h2 class="hasAnchor">
<a href="#complete-random-assignment" class="anchor"></a>Complete random assignment</h2>
<p>Complete random assignment is very similar to simple random assignment, except that the researcher can specify <em>exactly</em> how many units are assigned to each condition.</p>
<p>The syntax for <code><a href="../reference/complete_ra.html">complete_ra()</a></code> is very similar to that of <code><a href="../reference/simple_ra.html">simple_ra()</a></code>. The argument <code>m</code> is the number of units assigned to treatment in two-arm designs; it is analogous to <code><a href="../reference/simple_ra.html">simple_ra()</a></code>’s <code>prob</code>. Similarly, the argument <code>m_each</code> is analogous to <code>prob_each</code>.</p>
<p>If you only specify <code>N</code>, <code><a href="../reference/complete_ra.html">complete_ra()</a></code> assigns exactly half of the subjects to treatment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/complete_ra.html">complete_ra</a></span>(<span class="dt">N =</span> N)
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">296</td>
<td align="right">296</td>
</tr></tbody>
</table>
<p>To change the number of units assigned, specify the <code>m</code> argument:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/complete_ra.html">complete_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">m =</span> <span class="dv">200</span>)
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">392</td>
<td align="right">200</td>
</tr></tbody>
</table>
<p>If you specify multiple arms, <code><a href="../reference/complete_ra.html">complete_ra()</a></code> will assign an equal (within rounding) number of units to treatment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/complete_ra.html">complete_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">num_arms =</span> <span class="dv">3</span>)
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">197</td>
<td align="right">198</td>
<td align="right">197</td>
</tr></tbody>
</table>
<p>You can also specify exactly how many units should be assigned to each arm. The total of <code>m_each</code> must equal <code>N</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/complete_ra.html">complete_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">m_each =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">292</span>))
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">100</td>
<td align="right">200</td>
<td align="right">292</td>
</tr></tbody>
</table>
<p>You can also name your treatment arms.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/complete_ra.html">complete_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">m_each =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">292</span>),
               <span class="dt">conditions =</span> <span class="kw">c</span>(<span class="st">"control"</span>, <span class="st">"placebo"</span>, <span class="st">"treatment"</span>))
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">control</th>
<th align="right">placebo</th>
<th align="right">treatment</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">100</td>
<td align="right">200</td>
<td align="right">292</td>
</tr></tbody>
</table>
</div>
<div id="simple-and-complete-random-assignment-compared" class="section level2">
<h2 class="hasAnchor">
<a href="#simple-and-complete-random-assignment-compared" class="anchor"></a>Simple and Complete random assignment compared</h2>
<p>When should you use <code><a href="../reference/simple_ra.html">simple_ra()</a></code> versus <code><a href="../reference/complete_ra.html">complete_ra()</a></code>? Basically, if the number of units is known beforehand, <code><a href="../reference/complete_ra.html">complete_ra()</a></code> is always preferred, for two reasons: 1. Researchers can plan exactly how many treatments will be deployed. 2. The standard errors associated with complete random assignment are generally smaller, increasing experimental power. See this guide on <a href="http://egap.org/">EGAP</a> for more on <a href="http://egap.org/resources/guides/power/">experimental power</a>.</p>
<p>Since you need to know <code>N</code> beforehand in order to use <code><a href="../reference/simple_ra.html">simple_ra()</a></code>, it may seem like a useless function. Sometimes, however, the random assignment isn’t directly in the researcher’s control. For example, when deploying a survey exeriment on a platform like Qualtrics, simple random assignment is the only possibility due to the inflexibility of the built-in random assignment tools. When reconstructing the random assignment for analysis after the experiment has been conducted, <code><a href="../reference/simple_ra.html">simple_ra()</a></code> provides a convenient way to do so.<br>
To demonstrate how <code><a href="../reference/complete_ra.html">complete_ra()</a></code> is superior to <code><a href="../reference/simple_ra.html">simple_ra()</a></code>, let’s conduct a small simulation with our <code>HairEyeColor</code> dataset.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">sims &lt;-<span class="st"> </span><span class="dv">1000</span>

<span class="co"># Set up empty vectors to collect results</span>
simple_ests &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, sims)
complete_ests &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="ot">NA</span>, sims)

<span class="co"># Loop through simulation 2000 times</span>
<span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">1</span><span class="op">:</span>sims){
  hec &lt;-<span class="st"> </span><span class="kw">within</span>(hec,{
    
    <span class="co"># Conduct both kinds of random assignment</span>
    Z_simple &lt;-<span class="st"> </span><span class="kw"><a href="../reference/simple_ra.html">simple_ra</a></span>(<span class="dt">N =</span> N)
    Z_complete &lt;-<span class="st"> </span><span class="kw"><a href="../reference/complete_ra.html">complete_ra</a></span>(<span class="dt">N =</span> N)
    
    <span class="co"># Reveal observed potential outcomes</span>
    Y_simple &lt;-<span class="st"> </span>Y1<span class="op">*</span>Z_simple <span class="op">+</span><span class="st"> </span>Y0<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>Z_simple)
    Y_complete &lt;-<span class="st"> </span>Y1<span class="op">*</span>Z_complete <span class="op">+</span><span class="st"> </span>Y0<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>Z_complete)
    })
  
  <span class="co"># Estimate ATE under both models</span>
  fit_simple &lt;-<span class="st"> </span><span class="kw">lm</span>(Y_simple <span class="op">~</span><span class="st"> </span>Z_simple, <span class="dt">data=</span>hec)
  fit_complete &lt;-<span class="st"> </span><span class="kw">lm</span>(Y_complete <span class="op">~</span><span class="st"> </span>Z_complete, <span class="dt">data=</span>hec)
  
  <span class="co"># Save the estimates</span>
  simple_ests[i] &lt;-<span class="st"> </span><span class="kw">coef</span>(fit_simple)[<span class="dv">2</span>]
  complete_ests[i] &lt;-<span class="st"> </span><span class="kw">coef</span>(fit_complete)[<span class="dv">2</span>]
}</code></pre></div>
<p>The standard error of an estimate is defined as the standard deviation of the sampling distribution of the estimator. When standard errors are estimated (i.e., by using the <code>summary()</code> command on a model fit), they are estimated using some approximation. This simulation allows us to measure the standard error directly, since the vectors <code>simple_ests</code> and <code>complete_ests</code> describe the sampling distribution of each design.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sd</span>(simple_ests)</code></pre></div>
<p>0.63</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sd</span>(complete_ests)</code></pre></div>
<p>0.61</p>
<p>In this simulation complete random assignment led to a 4.64% decrease in sampling variability. This decrease was obtained with a small design tweak that costs the researcher essentially nothing.</p>
</div>
<div id="block-random-assignment" class="section level2">
<h2 class="hasAnchor">
<a href="#block-random-assignment" class="anchor"></a>Block random assignment</h2>
<p>Block random assignment (sometimes known as stratified random assignment) is a powerful tool when used well. In this design, subjects are sorted into blocks (strata) according to their pre-treatment covariates, and then complete random assignment is conducted within each block. For example, a researcher might block on gender, assigning exactly half of the men and exactly half of the women to treatment.</p>
<p>Why block? The first reason is to signal to future readers that treatment effect heterogeneity may be of interest: is the treatment effect different for men versus women? Of course, such heterogeneity could be explored if complete random assignment had been used, but blocking on a covariate defends a researcher (somewhat) against claims of data dredging. The second reason is to increase precision. If the blocking variables are predicitive of the outcome (i.e., they are correlated with the outcome), then blocking may help to decrease sampling variability. It’s important, however, not to overstate these advantages. The gains from a blocked design can often be realized through covariate adjustment alone.</p>
<p>Blocking can also produce complications for estimation. Blocking can produce different probabilities of assignment for different subjects. This complication is typically addressed in one of two ways: “controlling for blocks” in a regression context, or inverse probabilitity weights (IPW), in which units are weighted by the inverse of the probability that the unit is in the condition that it is in.</p>
<p>The only required argument to <code><a href="../reference/block_ra.html">block_ra()</a></code> is <code>blocks</code>, which is a vector of length <code>N</code> that describes which block a unit belongs to. <code>blocks</code> can be a factor, character, or numeric variable. If no other arguments are specified, <code><a href="../reference/block_ra.html">block_ra()</a></code> assigns an approximately equal proportion of each block to treatment.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair)
<span class="kw">table</span>(Z, hec<span class="op">$</span>Hair)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">Black</th>
<th align="right">Brown</th>
<th align="right">Red</th>
<th align="right">Blond</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>0</td>
<td align="right">54</td>
<td align="right">143</td>
<td align="right">35</td>
<td align="right">63</td>
</tr>
<tr class="even">
<td>1</td>
<td align="right">54</td>
<td align="right">143</td>
<td align="right">36</td>
<td align="right">64</td>
</tr>
</tbody>
</table>
<p>For multiple treatment arms, use the <code>num_arms</code> argument, with or without the <code>conditions</code> argument</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair, <span class="dt">num_arms =</span> <span class="dv">3</span>)
<span class="kw">table</span>(Z, hec<span class="op">$</span>Hair)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">Black</th>
<th align="right">Brown</th>
<th align="right">Red</th>
<th align="right">Blond</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>T1</td>
<td align="right">36</td>
<td align="right">95</td>
<td align="right">24</td>
<td align="right">42</td>
</tr>
<tr class="even">
<td>T2</td>
<td align="right">36</td>
<td align="right">96</td>
<td align="right">23</td>
<td align="right">43</td>
</tr>
<tr class="odd">
<td>T3</td>
<td align="right">36</td>
<td align="right">95</td>
<td align="right">24</td>
<td align="right">42</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair, <span class="dt">conditions =</span> <span class="kw">c</span>(<span class="st">"Control"</span>, <span class="st">"Placebo"</span>, <span class="st">"Treatment"</span>))
<span class="kw">table</span>(Z, hec<span class="op">$</span>Hair)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">Black</th>
<th align="right">Brown</th>
<th align="right">Red</th>
<th align="right">Blond</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Control</td>
<td align="right">36</td>
<td align="right">96</td>
<td align="right">24</td>
<td align="right">43</td>
</tr>
<tr class="even">
<td>Placebo</td>
<td align="right">36</td>
<td align="right">95</td>
<td align="right">23</td>
<td align="right">42</td>
</tr>
<tr class="odd">
<td>Treatment</td>
<td align="right">36</td>
<td align="right">95</td>
<td align="right">24</td>
<td align="right">42</td>
</tr>
</tbody>
</table>
<p><code><a href="../reference/block_ra.html">block_ra()</a></code> provides a number of ways to adjust the number of subjects assigned to each conditions. The <code>prob_each</code> argument describes what proportion of each block should be assigned to treatment arm. Note of course, that <code><a href="../reference/block_ra.html">block_ra()</a></code> still uses complete random assignment within each block; the appropriate number of units to assign to treatment within each block is automatically determined.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair, <span class="dt">prob_each =</span> <span class="kw">c</span>(.<span class="dv">3</span>, .<span class="dv">7</span>))
<span class="kw">table</span>(Z, hec<span class="op">$</span>Hair)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">Black</th>
<th align="right">Brown</th>
<th align="right">Red</th>
<th align="right">Blond</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>0</td>
<td align="right">33</td>
<td align="right">86</td>
<td align="right">21</td>
<td align="right">38</td>
</tr>
<tr class="even">
<td>1</td>
<td align="right">75</td>
<td align="right">200</td>
<td align="right">50</td>
<td align="right">89</td>
</tr>
</tbody>
</table>
<p>For finer control, use the <code>block_m_each</code> argument, which takes a matrix with as many rows as there are blocks, and as many columns as there are treatment conditions. Remember that the rows are in the same order as <code>sort(unique(blocks))</code>, a command that is good to run before constructing a <code>block_m_each</code> matrix.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">sort</span>(<span class="kw">unique</span>(hec<span class="op">$</span>Hair))
block_m_each &lt;-<span class="st"> </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">78</span>, <span class="dv">30</span>),
                      <span class="kw">c</span>(<span class="dv">186</span>, <span class="dv">100</span>),
                      <span class="kw">c</span>(<span class="dv">51</span>, <span class="dv">20</span>),
                      <span class="kw">c</span>(<span class="dv">87</span>,<span class="dv">40</span>))

block_m_each
Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair, <span class="dt">block_m_each =</span> block_m_each)
<span class="kw">table</span>(Z, hec<span class="op">$</span>Hair)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">Black</th>
<th align="right">Brown</th>
<th align="right">Red</th>
<th align="right">Blond</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>0</td>
<td align="right">78</td>
<td align="right">186</td>
<td align="right">51</td>
<td align="right">87</td>
</tr>
<tr class="even">
<td>1</td>
<td align="right">30</td>
<td align="right">100</td>
<td align="right">20</td>
<td align="right">40</td>
</tr>
</tbody>
</table>
<p>In the example above, the different blocks have different probabilities of assignment to treatment. In this case, people with Black hair have a 30/108 = 27.8% chance of being treated, those with Brown hair have 100/286 = 35.0% change, etc. Left unadressed, this discrepancy could bias treatment effects. We can see this directly with the <code><a href="../reference/declare_ra.html">declare_ra()</a></code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">declaration &lt;-<span class="st"> </span><span class="kw"><a href="../reference/declare_ra.html">declare_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair, <span class="dt">block_m_each =</span> block_m_each)

<span class="co"># show the probability that each unit is assigned to each condition</span>
<span class="kw">head</span>(declaration<span class="op">$</span>probabilities_matrix)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">prob_0</th>
<th align="right">prob_1</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="even">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="odd">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="even">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="odd">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="even">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># Show that the probability of treatment is different within block</span>
<span class="kw">table</span>(hec<span class="op">$</span>Hair, <span class="kw">round</span>(declaration<span class="op">$</span>probabilities_matrix[,<span class="dv">2</span>], <span class="dv">3</span>))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">0.278</th>
<th align="right">0.282</th>
<th align="right">0.315</th>
<th align="right">0.35</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Black</td>
<td align="right">108</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Brown</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">286</td>
</tr>
<tr class="odd">
<td>Red</td>
<td align="right">0</td>
<td align="right">71</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Blond</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">127</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p>There are two common ways to address this problem: LSDV (Least-Squares Dummy Variable, also known as “control for blocks”) or IPW (Inverse-probability weights).</p>
<p>The following code snippet shows how to use either the LSDV approach or the IPW approach. A note for scrupulous readers: the estimands of these two approaches are subtly different from one another. The LSDV approach estimates the average <strong>block-level</strong> treatment effect. The IPW approach estimates the average <strong>individual-level</strong> treatment effect. They can be different. Since the average block-level treatment effect is not what most people have in mind when thinking about causal effects, analysts using this approach should present both. The <code><a href="../reference/obtain_condition_probabilities.html">obtain_condition_probabilities()</a></code> function used to calculate the probabilities of assignment is explained below.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hec &lt;-<span class="st"> </span><span class="kw">within</span>(hec,{
  Z_blocked &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair,
                        <span class="dt">block_m_each =</span> block_m_each)
  Y_blocked &lt;-<span class="st"> </span>Y1<span class="op">*</span>(Z_blocked) <span class="op">+</span><span class="st"> </span>Y0<span class="op">*</span>(<span class="dv">1</span><span class="op">-</span>Z_blocked)
  cond_prob &lt;-<span class="st"> </span><span class="kw"><a href="../reference/obtain_condition_probabilities.html">obtain_condition_probabilities</a></span>(declaration, Z_blocked)
  IPW_weights &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">/</span>(cond_prob)
})

fit_LSDV &lt;-<span class="st"> </span><span class="kw">lm</span>(Y_blocked <span class="op">~</span><span class="st"> </span>Z_blocked <span class="op">+</span><span class="st"> </span>Hair, <span class="dt">data=</span>hec)
fit_IPW &lt;-<span class="st"> </span><span class="kw">lm</span>(Y_blocked <span class="op">~</span><span class="st"> </span>Z_blocked, <span class="dt">weights =</span> IPW_weights, <span class="dt">data =</span> hec)

<span class="kw">summary</span>(fit_LSDV)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">Estimate</th>
<th align="right">Std. Error</th>
<th align="right">t value</th>
<th align="right">Pr(&gt;|t|)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>(Intercept)</td>
<td align="right">-15.8</td>
<td align="right">0.72</td>
<td align="right">-22.0</td>
<td align="right">0.00</td>
</tr>
<tr class="even">
<td>Z_blocked</td>
<td align="right">24.9</td>
<td align="right">0.64</td>
<td align="right">38.8</td>
<td align="right">0.00</td>
</tr>
<tr class="odd">
<td>HairBrown</td>
<td align="right">2.0</td>
<td align="right">0.82</td>
<td align="right">2.4</td>
<td align="right">0.02</td>
</tr>
<tr class="even">
<td>HairRed</td>
<td align="right">4.9</td>
<td align="right">1.11</td>
<td align="right">4.5</td>
<td align="right">0.00</td>
</tr>
<tr class="odd">
<td>HairBlond</td>
<td align="right">8.9</td>
<td align="right">0.95</td>
<td align="right">9.4</td>
<td align="right">0.00</td>
</tr>
</tbody>
</table>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">summary</span>(fit_IPW)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">Estimate</th>
<th align="right">Std. Error</th>
<th align="right">t value</th>
<th align="right">Pr(&gt;|t|)</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>(Intercept)</td>
<td align="right">-12</td>
<td align="right">0.49</td>
<td align="right">-25</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Z_blocked</td>
<td align="right">25</td>
<td align="right">0.69</td>
<td align="right">36</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p>How to create blocks? In the <code>HairEyeColor</code> dataset, we could make blocks for each unique combination of hair color, eye color, and sex.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">blocks &lt;-<span class="st"> </span><span class="kw">with</span>(hec, <span class="kw">paste</span>(Hair, Eye, Sex, <span class="dt">sep =</span> <span class="st">"_"</span>))
Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> blocks)
<span class="kw">head</span>(<span class="kw">table</span>(blocks, Z))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Black_Blue_Female</td>
<td align="right">5</td>
<td align="right">4</td>
</tr>
<tr class="even">
<td>Black_Blue_Male</td>
<td align="right">6</td>
<td align="right">5</td>
</tr>
<tr class="odd">
<td>Black_Brown_Female</td>
<td align="right">18</td>
<td align="right">18</td>
</tr>
<tr class="even">
<td>Black_Brown_Male</td>
<td align="right">16</td>
<td align="right">16</td>
</tr>
<tr class="odd">
<td>Black_Green_Female</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td>Black_Green_Male</td>
<td align="right">1</td>
<td align="right">2</td>
</tr>
</tbody>
</table>
<p>An alternative is to use the <code>blockTools</code> package, which constructs matched pairs, trios, quartets, etc. from pretreatment covariates.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(blockTools)

<span class="co"># BlockTools requires that all variables be numeric</span>
numeric_mat &lt;-<span class="st"> </span><span class="kw">model.matrix</span>(<span class="op">~</span>Hair<span class="op">+</span>Eye<span class="op">+</span>Sex, <span class="dt">data=</span>hec)[,<span class="op">-</span><span class="dv">1</span>]

<span class="co"># BlockTools also requres an id variable</span>
df_forBT &lt;-<span class="st"> </span><span class="kw">data.frame</span>(<span class="dt">id_var =</span> <span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(numeric_mat), numeric_mat)

<span class="co"># Conducting the actual blocking: let's make trios</span>
out &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/blockTools/topics/block">block</a></span>(df_forBT, <span class="dt">n.tr =</span> <span class="dv">3</span>, <span class="dt">id.vars =</span> <span class="st">"id_var"</span>, 
             <span class="dt">block.vars =</span> <span class="kw">colnames</span>(df_forBT)[<span class="op">-</span><span class="dv">1</span>])

<span class="co"># Extact the block_ids</span>
hec<span class="op">$</span>block_id &lt;-<span class="st"> </span><span class="kw"><a href="http://www.rdocumentation.org/packages/blockTools/topics/createBlockIDs">createBlockIDs</a></span>(out, df_forBT, <span class="dt">id.var =</span> <span class="st">"id_var"</span>)

<span class="co"># Conduct actual random assignment with randomizr</span>
Z_blocked &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>block_id, <span class="dt">num_arms =</span> <span class="dv">3</span>)
<span class="kw">head</span>(<span class="kw">table</span>(hec<span class="op">$</span>block_id, Z_blocked))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="odd">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
<tr class="even">
<td align="right">1</td>
<td align="right">1</td>
<td align="right">1</td>
</tr>
</tbody>
</table>
<p>A note for <code>blockTools</code> users: that package also has an assignment function. My preference is to extract the blocking variable, then conduct the assignment with <code><a href="../reference/block_ra.html">block_ra()</a></code>, so that fewer steps are required to reconstruct the random assignment or generate new random assignments for a randomization inference procedure.</p>
</div>
<div id="clustered-assignment" class="section level2">
<h2 class="hasAnchor">
<a href="#clustered-assignment" class="anchor"></a>Clustered assignment</h2>
<p>Clustered assignment is unfortunate. If you can avoid assigning subjects to treatments by cluster, you should. Sometimes, clustered assignment is unavoidable. Some common situations include:</p>
<ol style="list-style-type: decimal">
<li>Housemates in households: whole households are assigned to treatment or control</li>
<li>Students in classrooms: whole classrooms are assigned to treatment or control</li>
<li>Residents in towns or villages: whole communities are assigned to treatment or control</li>
</ol>
<p>Clustered assignment decreases the effective sample size of an experiment. In the extreme case when outcomes are perfectly correlated with clusters, the experiment has an effective sample size equal to the number of clusters. When outcomes are perfectly uncorrelated with clusters, the effective sample size is equal to the number of subjects. Almost all cluster-assigned experiments fall somewhere in the middle of these two extremes.</p>
<p>The only required argument for the <code><a href="../reference/cluster_ra.html">cluster_ra()</a></code> function is the <code>clusters</code> argument, which is a vector of length <code>N</code> that indicates which cluster each subject belongs to. Let’s pretend that for some reason, we have to assign treatments according to the unique combinations of hair color, eye color, and gender.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">clusters &lt;-<span class="st"> </span><span class="kw">with</span>(hec, <span class="kw">paste</span>(Hair, Eye, Sex, <span class="dt">sep =</span> <span class="st">"_"</span>))
hec<span class="op">$</span>clusters &lt;-<span class="st"> </span>clusters

Z_clust &lt;-<span class="st"> </span><span class="kw"><a href="../reference/cluster_ra.html">cluster_ra</a></span>(<span class="dt">clusters =</span> clusters)

<span class="kw">head</span>(<span class="kw">table</span>(clusters, Z_clust))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Black_Blue_Female</td>
<td align="right">9</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Blue_Male</td>
<td align="right">0</td>
<td align="right">11</td>
</tr>
<tr class="odd">
<td>Black_Brown_Female</td>
<td align="right">0</td>
<td align="right">36</td>
</tr>
<tr class="even">
<td>Black_Brown_Male</td>
<td align="right">0</td>
<td align="right">32</td>
</tr>
<tr class="odd">
<td>Black_Green_Female</td>
<td align="right">0</td>
<td align="right">2</td>
</tr>
<tr class="even">
<td>Black_Green_Male</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p>This shows that each cluster is either assigned to treatment or control. No two units within the same cluster are assigned to different conditions.</p>
<p>As with all functions in <code>randomizr</code>, you can specify multiple treatment arms in a variety of ways:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z_clust &lt;-<span class="st"> </span><span class="kw"><a href="../reference/cluster_ra.html">cluster_ra</a></span>(<span class="dt">clusters =</span> clusters, <span class="dt">num_arms =</span> <span class="dv">3</span>)
<span class="kw">head</span>(<span class="kw">table</span>(clusters, Z_clust))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Black_Blue_Female</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">9</td>
</tr>
<tr class="even">
<td>Black_Blue_Male</td>
<td align="right">11</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>Black_Brown_Female</td>
<td align="right">0</td>
<td align="right">36</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Brown_Male</td>
<td align="right">32</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>Black_Green_Female</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Green_Male</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p>… or using <code>conditions</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z_clust &lt;-<span class="st"> </span><span class="kw"><a href="../reference/cluster_ra.html">cluster_ra</a></span>(<span class="dt">clusters=</span>clusters, 
                      <span class="dt">conditions=</span><span class="kw">c</span>(<span class="st">"Control"</span>, <span class="st">"Placebo"</span>, <span class="st">"Treatment"</span>))
<span class="kw">head</span>(<span class="kw">table</span>(clusters, Z_clust))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">Control</th>
<th align="right">Placebo</th>
<th align="right">Treatment</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Black_Blue_Female</td>
<td align="right">0</td>
<td align="right">9</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Blue_Male</td>
<td align="right">0</td>
<td align="right">11</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>Black_Brown_Female</td>
<td align="right">36</td>
<td align="right">0</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Brown_Male</td>
<td align="right">0</td>
<td align="right">32</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>Black_Green_Female</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Green_Male</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<p>… or using <code>m_each</code>, which describes how many clusters should be assigned to each condition. <code>m_each</code> must sum to the number of clusters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z_clust &lt;-<span class="st"> </span><span class="kw"><a href="../reference/cluster_ra.html">cluster_ra</a></span>(<span class="dt">clusters=</span>clusters, <span class="dt">m_each=</span><span class="kw">c</span>(<span class="dv">5</span>, <span class="dv">15</span>, <span class="dv">12</span>))
<span class="kw">head</span>(<span class="kw">table</span>(clusters, Z_clust))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Black_Blue_Female</td>
<td align="right">0</td>
<td align="right">9</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Blue_Male</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">11</td>
</tr>
<tr class="odd">
<td>Black_Brown_Female</td>
<td align="right">0</td>
<td align="right">36</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Brown_Male</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">32</td>
</tr>
<tr class="odd">
<td>Black_Green_Female</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Green_Male</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
</div>
<div id="blocked-and-clustered-assignment" class="section level2">
<h2 class="hasAnchor">
<a href="#blocked-and-clustered-assignment" class="anchor"></a>Blocked and clustered assignment</h2>
<p>The power of clustered experiments can sometimes be improved through blocking. In this scenario, whole clusters are members of a particular block – imagine villages nested within discrete regions, or classrooms nested within discrete schools.</p>
<p>As an example, let’s group our clusters into blocks by size using <code>dplyr</code></p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">suppressMessages</span>(<span class="kw">library</span>(dplyr))
cluster_level_df &lt;-<span class="st"> </span>
<span class="st">  </span>hec <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/group_by.html">group_by</a></span>(clusters) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/summarise.html">summarize</a></span>(<span class="dt">cluster_size =</span> <span class="kw"><a href="http://dplyr.tidyverse.org/reference/n.html">n</a></span>()) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/arrange.html">arrange</a></span>(cluster_size) <span class="op">%&gt;%</span>
<span class="st">  </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/mutate.html">mutate</a></span>(<span class="dt">blocks =</span> <span class="kw">paste0</span>(<span class="st">"block_"</span>, <span class="kw">sprintf</span>(<span class="st">"%02d"</span>,<span class="kw">rep</span>(<span class="dv">1</span><span class="op">:</span><span class="dv">16</span>, <span class="dt">each=</span><span class="dv">2</span>))))

hec &lt;-<span class="st"> </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/join.html">left_join</a></span>(hec, cluster_level_df)
<span class="co">#&gt; Joining, by = "clusters"</span>

<span class="co"># Extract the cluster and block variables</span>
clusters &lt;-<span class="st"> </span>hec<span class="op">$</span>clusters
blocks &lt;-<span class="st"> </span>hec<span class="op">$</span>blocks

Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_and_cluster_ra.html">block_and_cluster_ra</a></span>(<span class="dt">clusters =</span> clusters, <span class="dt">blocks =</span> blocks)
<span class="kw">head</span>(<span class="kw">table</span>(clusters, Z))
<span class="kw">head</span>(<span class="kw">table</span>(blocks, Z))</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Black_Blue_Female</td>
<td align="right">0</td>
<td align="right">9</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Blue_Male</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">11</td>
</tr>
<tr class="odd">
<td>Black_Brown_Female</td>
<td align="right">0</td>
<td align="right">36</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Brown_Male</td>
<td align="right">0</td>
<td align="right">0</td>
<td align="right">32</td>
</tr>
<tr class="odd">
<td>Black_Green_Female</td>
<td align="right">0</td>
<td align="right">2</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>Black_Green_Male</td>
<td align="right">0</td>
<td align="right">3</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">T1</th>
<th align="right">T2</th>
<th align="right">T3</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>block_01</td>
<td align="right">0</td>
<td align="right">5</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>block_02</td>
<td align="right">0</td>
<td align="right">4</td>
<td align="right">3</td>
</tr>
<tr class="odd">
<td>block_03</td>
<td align="right">0</td>
<td align="right">5</td>
<td align="right">5</td>
</tr>
<tr class="even">
<td>block_04</td>
<td align="right">7</td>
<td align="right">5</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>block_05</td>
<td align="right">0</td>
<td align="right">7</td>
<td align="right">7</td>
</tr>
<tr class="even">
<td>block_06</td>
<td align="right">0</td>
<td align="right">7</td>
<td align="right">7</td>
</tr>
</tbody>
</table>
</div>
<div id="calculating-probabilities-of-assignment" class="section level2">
<h2 class="hasAnchor">
<a href="#calculating-probabilities-of-assignment" class="anchor"></a>Calculating probabilities of assignment</h2>
<p>All five random assignment functions in <code>randomizr</code> assign units to treatment with known (if sometimes complicated) probabilities. The <code><a href="../reference/declare_ra.html">declare_ra()</a></code> and <code><a href="../reference/obtain_condition_probabilities.html">obtain_condition_probabilities()</a></code> functions calculate these probabilities according to the parameters of your experimental design.</p>
<p>Let’s take a look at the block random assignment we used before.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">block_m_each &lt;-<span class="st"> </span>
<span class="st">  </span><span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">78</span>, <span class="dv">30</span>),
        <span class="kw">c</span>(<span class="dv">186</span>, <span class="dv">100</span>),
        <span class="kw">c</span>(<span class="dv">51</span>, <span class="dv">20</span>),
        <span class="kw">c</span>(<span class="dv">87</span>, <span class="dv">40</span>))
  
Z &lt;-<span class="st"> </span><span class="kw"><a href="../reference/block_ra.html">block_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair,
              <span class="dt">block_m_each =</span> block_m_each)

<span class="kw">table</span>(hec<span class="op">$</span>Hair, Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>Black</td>
<td align="right">78</td>
<td align="right">30</td>
</tr>
<tr class="even">
<td>Brown</td>
<td align="right">186</td>
<td align="right">100</td>
</tr>
<tr class="odd">
<td>Red</td>
<td align="right">51</td>
<td align="right">20</td>
</tr>
<tr class="even">
<td>Blond</td>
<td align="right">87</td>
<td align="right">40</td>
</tr>
</tbody>
</table>
<p>In order to calculate the probabilities of assignment, we call the <code><a href="../reference/declare_ra.html">declare_ra()</a></code> function with the same exact arguments as we used for the <code><a href="../reference/block_ra.html">block_ra()</a></code> call. The <code>declaration</code> object contains a matrix of probabilities of assignment:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">declaration &lt;-<span class="st"> </span><span class="kw"><a href="../reference/declare_ra.html">declare_ra</a></span>(<span class="dt">blocks =</span> hec<span class="op">$</span>Hair,
                          <span class="dt">block_m_each =</span> block_m_each)
prob_mat &lt;-<span class="st"> </span>declaration<span class="op">$</span>probabilities_matrix
<span class="kw">head</span>(prob_mat)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">prob_0</th>
<th align="right">prob_1</th>
</tr></thead>
<tbody>
<tr class="odd">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="even">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="odd">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="even">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="odd">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
<tr class="even">
<td align="right">0.72</td>
<td align="right">0.28</td>
</tr>
</tbody>
</table>
<p>The <code>prob_mat</code> objects has <code>N</code> rows and as many columns as there are treatment conditions, in this case 2.</p>
<p>In order to use inverse-probability weights, we need to know the probability of each unit being in the <strong>condition that it is in</strong>. For each unit, we need to pick the appropriate probability. This bookkeeping is handled automatically by the <code><a href="../reference/obtain_condition_probabilities.html">obtain_condition_probabilities()</a></code> function.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">cond_prob &lt;-<span class="st"> </span><span class="kw"><a href="../reference/obtain_condition_probabilities.html">obtain_condition_probabilities</a></span>(declaration, Z)
<span class="kw">table</span>(cond_prob, Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th></th>
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody>
<tr class="odd">
<td>0.28</td>
<td align="right">0</td>
<td align="right">30</td>
</tr>
<tr class="even">
<td>0.28</td>
<td align="right">0</td>
<td align="right">20</td>
</tr>
<tr class="odd">
<td>0.31</td>
<td align="right">0</td>
<td align="right">40</td>
</tr>
<tr class="even">
<td>0.35</td>
<td align="right">0</td>
<td align="right">100</td>
</tr>
<tr class="odd">
<td>0.65</td>
<td align="right">186</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>0.69</td>
<td align="right">87</td>
<td align="right">0</td>
</tr>
<tr class="odd">
<td>0.72</td>
<td align="right">51</td>
<td align="right">0</td>
</tr>
<tr class="even">
<td>0.72</td>
<td align="right">78</td>
<td align="right">0</td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="best-practices" class="section level1">
<h1 class="hasAnchor">
<a href="#best-practices" class="anchor"></a>Best practices</h1>
<div id="random-assignment-procedure-random-assignment-function" class="section level2">
<h2 class="hasAnchor">
<a href="#random-assignment-procedure-random-assignment-function" class="anchor"></a>Random assignment procedure = Random assignment <strong>function</strong>
</h2>
<p>Random assignment procedures are often described as a series of steps that are manually carried out be the researcher. In order to make this procedure reproducible, these steps need to be translated into a <strong>function</strong> that returns a different random assignment each time it is called.</p>
<p>For example, consider the following procedure for randomly allocating school vouchers.</p>
<ol style="list-style-type: decimal">
<li>Every eligible student’s names is put on a list</li>
<li>Each name is assigned a random number</li>
<li>Balls with the numbers associated with all students are put in an urn.</li>
<li>Then the urn is “shuffled”</li>
<li>Students names are drawn one by one from the urn until all slots are given out.</li>
<li>If one sibling in a family wins, all other siblings automatically win too.</li>
</ol>
<p>If we write such a procedure into a function, it might look like this:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="co"># 400 families have 1 child in the lottery, 100 families have 2</span>
family_id &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="kw">sprintf</span>(<span class="st">"%03d"</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">500</span>), <span class="kw">sprintf</span>(<span class="st">"%03d"</span>, <span class="dv">1</span><span class="op">:</span><span class="dv">100</span>))

school_ra &lt;-<span class="st"> </span><span class="cf">function</span>(m){
  N &lt;-<span class="st"> </span><span class="kw">length</span>(family_id)
  random_number &lt;-<span class="st"> </span><span class="kw"><a href="http://dplyr.tidyverse.org/reference/sample.html">sample</a></span>(<span class="dv">1</span><span class="op">:</span>N, <span class="dt">replace=</span><span class="ot">FALSE</span>)
  Z &lt;-<span class="st"> </span><span class="kw">rep</span>(<span class="dv">0</span>, N)
  i &lt;-<span class="st"> </span><span class="dv">1</span>
  <span class="cf">while</span>(<span class="kw">sum</span>(Z) <span class="op">&lt;</span>m){
    Z[family_id<span class="op">==</span>family_id[random_number[i]]] &lt;-<span class="st"> </span><span class="dv">1</span>
    i &lt;-<span class="st"> </span>i <span class="op">+</span><span class="st"> </span><span class="dv">1</span>
  }
  <span class="kw">return</span>(Z)
}

Z &lt;-<span class="st"> </span><span class="kw">school_ra</span>(<span class="dv">200</span>)
<span class="kw">table</span>(Z)</code></pre></div>
<table class="table">
<thead><tr class="header">
<th align="right">0</th>
<th align="right">1</th>
</tr></thead>
<tbody><tr class="odd">
<td align="right">400</td>
<td align="right">200</td>
</tr></tbody>
</table>
<p>This assignment procedure is complicated by the sibling rule, which has two effects: first, students are cluster-assigned by family, and second, the probability of assignment varies student to student. Obviously, families who have two children in the lottery have a higher probability of winning the lottery because they effectively have two “tickets.” There may be better ways of running this assignment procedure (for example, with <code><a href="../reference/cluster_ra.html">cluster_ra()</a></code>), but the purpose of this example is to show how complicated <em>real-world</em> procedures can be written up in a simple function. With this function, the random assignment procedure can be reproduced exactly, the complicated probabilities of assignment can be caluculated, and the analysis is greatly simplified.</p>
</div>
<div id="check-probabilities-of-assignment-directly" class="section level2">
<h2 class="hasAnchor">
<a href="#check-probabilities-of-assignment-directly" class="anchor"></a>Check probabilities of assignment directly</h2>
<p>For many designs, the probability of assignment to treatment can be calculated analytically. For example, in a completely randomized design with 200 units, 60 of which are assigned to treatment, the probability is exactly 0.30 for all units. However, in more complicated designs (such as the schools example described above), analytic probabilities are difficult to calculate. In such a situation, an easy way to obtain the probabilities of assignment is through simulation.</p>
<ol style="list-style-type: decimal">
<li>Call your random assignment function an approximately infinite number of times (about 10,000 for most purposes).</li>
<li>Count how often each unit is assigned to each treatment arm.</li>
</ol>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">Z_matrix &lt;-<span class="st"> </span><span class="kw">replicate</span>(<span class="dv">1000</span>, <span class="kw">school_ra</span>(<span class="dv">200</span>))
<span class="kw">plot</span>(<span class="kw">rowMeans</span>(Z_matrix))</code></pre></div>
<p><img src="randomizr_vignette_files/figure-html/unnamed-chunk-67-1.png" width="700"></p>
<p>This plot shows that the students who have a sibling in the lottery have a higher probability of assignment. The more simulations, the more precise the estimate of the probability of assignment.</p>
</div>
<div id="save-your-random-assignment" class="section level2">
<h2 class="hasAnchor">
<a href="#save-your-random-assignment" class="anchor"></a>Save your random assignment</h2>
<p>Whenever you conduct a random assignment for use in an experiment, save it! At a minimum, the random assignment should be saved with an id variable in a csv.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">hec &lt;-<span class="st"> </span><span class="kw">within</span>(hec,{
  Z_blocked &lt;-<span class="st"> </span><span class="kw"><a href="../reference/complete_ra.html">complete_ra</a></span>(<span class="dt">N =</span> N, <span class="dt">m_each =</span> <span class="kw">c</span>(<span class="dv">100</span>, <span class="dv">200</span>, <span class="dv">292</span>),
               <span class="dt">conditions =</span> <span class="kw">c</span>(<span class="st">"control"</span>, <span class="st">"placebo"</span>, <span class="st">"treatment"</span>))
  id_var &lt;-<span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(hec)
})
<span class="kw">write.csv</span>(hec[,<span class="kw">c</span>(<span class="st">"id_var"</span>, <span class="st">"Z_blocked"</span>)], <span class="dt">file =</span> <span class="st">"MyRandomAssignment.csv"</span>)</code></pre></div>
</div>
</div>
  </div>

  <div class="col-md-3 hidden-xs hidden-sm" id="sidebar">
        <div id="tocnav">
      <h2 class="hasAnchor">
<a href="#tocnav" class="anchor"></a>Contents</h2>
      <ul class="nav nav-pills nav-stacked">
<li>
<a href="#a-hypothetical-experiment">A hypothetical experiment</a><ul class="nav nav-pills nav-stacked">
<li><a href="#simple-random-assignment">Simple random assignment</a></li>
      <li><a href="#complete-random-assignment">Complete random assignment</a></li>
      <li><a href="#simple-and-complete-random-assignment-compared">Simple and Complete random assignment compared</a></li>
      <li><a href="#block-random-assignment">Block random assignment</a></li>
      <li><a href="#clustered-assignment">Clustered assignment</a></li>
      <li><a href="#blocked-and-clustered-assignment">Blocked and clustered assignment</a></li>
      <li><a href="#calculating-probabilities-of-assignment">Calculating probabilities of assignment</a></li>
      </ul>
</li>
      <li>
<a href="#best-practices">Best practices</a><ul class="nav nav-pills nav-stacked">
<li><a href="#random-assignment-procedure-random-assignment-function">Random assignment procedure = Random assignment <strong>function</strong></a></li>
      <li><a href="#check-probabilities-of-assignment-directly">Check probabilities of assignment directly</a></li>
      <li><a href="#save-your-random-assignment">Save your random assignment</a></li>
      </ul>
</li>
      </ul>
</div>
      </div>

</div>


      <footer><div class="copyright" style="flex:2;">
  <p>Developed by Alexander Coppock.</p>
  <p>Code is licensed under <a href="https://opensource.org/licenses/mit-license.php">MIT</a> license.</p>
</div>

<div class="pkgdown">
  <p>Site built with <a href="http://hadley.github.io/pkgdown/">pkgdown</a>.</p>
</div>

      </footer>
</div>

  </body>
</html>
